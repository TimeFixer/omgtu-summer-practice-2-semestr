#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №7.Реализация потока обработки команад.

**Цель:** Реализовать основу для многопоточного сервера приложений.

**Результаты:** После выполнения работы Вы сможете:
1. Обрабатывать множество операций в несколько потоков.
2. Останавливать потоки по запросу извне.

## Задание.
Пусть операция задана интерфейсом

#!csharp

public interface ICommand
{
    void Execute();
}

#!markdown

Классы, наследующие интерйес ICommand будем называть **Командами.**

Реализовать класс ServerThread и команды по hard и soft завершению потока. 

ServerThread может менять свое поведение для обработки следующей Команды.
Исключение, выброшенное из Команды, перехватывается и передается вместе с самой Командой в ExceptionHandler (см. ЛР №5) Примечание. Наличие реализованного обработчика исключений не обязательно для выполнения данной задачи. 

Команда HardStop приводит к немедленной остановке потока, несмотря на, что в очереди потока есть еще Команды.
Команда  SoftStop останавливает поток, когда в очереди потока закончатся все Команды.

Команды HardStop и SoftStop успешно выполняются только в потоке, который они должны остановить, в противном случае выбрасывают исключение.
Отсутствие Команд в очереди потока не должно требовать значительных затрат процессорного времени. Значительными считаются затраты, которые зависят от времени простоя потока.

Написать проверку, которая гарантирует правильное выполнение команд HardStop и SoftStop.

#!csharp

using System;
using System.Collections.Concurrent;
using System.Threading;

public class ServerThread
{
    static bool soft = false;

    static bool stopped = false;
    static AutoResetEvent AutoResetEvent = new AutoResetEvent(false);
    static ConcurrentQueue<ICommand> ConcurrentQueue = new ConcurrentQueue<ICommand>();
    static Thread thread = new Thread(() =>
    {
        while (!stopped)
        {
            if (ConcurrentQueue.Count != 0)
            {
                ConcurrentQueue.TryDequeue(out ICommand command);
                try
                {
                    command.Execute();
                }
                catch (Exception e){}
            }
            else if (ConcurrentQueue.Count == 0 && !soft)
            {
                AutoResetEvent.WaitOne();
            }
        }
        
    });
    

    public void AddCommand(ICommand command)
    {
        ConcurrentQueue.Enqueue(command);
    }

    public void HardStop()
    {
        Thread.CurrentThread.Interrupt();
    }

    public void SoftStop()
    {
        stopped = true;
    }


public class HardStopCommand : ICommand
{
    private ServerThread serverThread;

    public HardStopCommand(ServerThread serverThread)
    {
        this.serverThread = serverThread;
    }

    public void Execute()
    {
        if (Thread.CurrentThread == thread)
        {
            serverThread.HardStop();
        }
    }
}

public class SoftStopCommand : ICommand
{
    private ServerThread serverThread;

    public SoftStopCommand(ServerThread serverThread)
    {
        this.serverThread = serverThread;
    }

    public void Execute()
    {
        if (Thread.CurrentThread == thread)
        {
            serverThread.SoftStop();
        }
    }
}
    public void Start()
    {
        thread.Start();
    }
}
public class TestSoft : ICommand
{
    public void Execute()
    {
        Console.WriteLine("тест soft");
    }
}
public class TestHard : ICommand
{
    public void Execute()
    {
        Console.WriteLine("тест hard");
    }
}

#!csharp

        ServerThread serverThread = new ServerThread();
        serverThread.Start();

        ICommand hardStopCommand = new ServerThread.HardStopCommand(serverThread);
        


        serverThread.AddCommand(new TestHard());
        serverThread.AddCommand(hardStopCommand);

#!csharp

ServerThread serverThread = new ServerThread();
serverThread.Start();
ICommand softStopCommand = new ServerThread.SoftStopCommand(serverThread);
serverThread.AddCommand(new TestSoft());
serverThread.AddCommand(softStopCommand);
